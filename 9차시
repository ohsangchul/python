[ 실습 내용 : 14_perfectNumber.py ]
# 4~1000 사이의 완전수를 구하고 완전수의 개수를 출력하는 프로그램
# 완전수 : 자기 자신을 제외한 약수의 합이 자신과 같은 숫자
# 예) 6의 약수 : 1, 2, 3, 6
#     자기 자신 6을 제외한 나머지 약수의 1, 2, 3의 합계가 자기 자신인 6이 되므로 6은 완전수이다.

count = 0
for i in range(4, 1001): # 4~1000까지 자연수 범위
    # 모수를 나눌 수 있는 가장 큰 수는 모수 자기 자신을 제외하면 1/2 크기를 넘지 않는다.
    k = i // 2
    # for문안에서 for을 사용할 경우 제어 변수가 겹치지 않게 한다.
    total = 0
    for j in range(1, k + 1):
        # 자연수의 약수 합계(total)를 계산한다.
        if i % j == 0: # j가 i의 약수인가?
            total += j # j가 i의 약수이면 약수의 합계를 위해 더한다.
    # 완전수인지 판단한다.
    if total == i: # 완전수인가?
        count += 1 # 완전수의 개수를 +1 한다.
        # 찾은 완전수를 출력한다.
        print('{0}번째 완전수는 {1:3d} 입니다.'.format(count, i))
print('1~1000 사이의 완전수는 {}개 입니다.'.format(count))
#=============== RESTART: D:\osc\workspace\14_perfectNumber.py ===============
#1번째 완전수는   6 입니다.
#2번째 완전수는  28 입니다.
#3번째 완전수는 496 입니다.
#1~1000 사이의 완전수는 3개 입니다.


[ 실습 내용 : 15_fibonacci.py ]
# 피보나치 수열 : 피보나치 수열의 n번째 값은 피보나치 수열을 n-1번째 값과 n-2번째 값을 더한 값이다.
# P = 1 + 1 + 2 + 3 + 5 + 8 + 13 + 21 + ...

# 수열의 합계를 계산할 항(n)을 입력받아 n번째 항까지 피보나치 수열의 합계를 계산하는 프로그램
# 첫번째 항과 두번째 항은 이미 계산이 되어있다고 가정하고 시작한다.

first_num = 1 # 피보나치 수열의 첫번째 항
second_num = 1 # 피보나치 수열의 두번째 항
total = 2 # 첫번째 항과 두번째 항의 합계를 미리 계산해둔 변수

n = int(input('합계를 계산할 항 : '))
# 첫번째 항과 두번째 항의 합계는 이미 계산이 되어있다는 가정하에 시작하므로 세번째 항부터 n번째 항까지 반복하며 합계를 계산한다.
for num in range(3, n + 1):
    next_num = first_num + second_num  # 피보나치 수열의 i번째 항을 계산한다.
    total += next_num # 피보나치 수열의 합계를 계산한다.
    first_num = second_num
    second_num = next_num

print('피보나치 수열의 {}번째 항 까지의 합계는 {} 입니다.'.format(n, total))
#================= RESTART: D:\osc\workspace\15_fibonacci.py =================
#합계를 계산할 항 : 10
#피보나치 수열의 10번째 항 까지의 합계는 143 입니다.


[ 실습 내용 : 16_fileReadWrite.py ]
### 파일 열기
### 파일변수 = open('텍스트파일명', '파일열기모드')
### 파일 모드
### r : read (읽기 전용)
### w : write (쓰기 전용)
### a : append (쓰기, 추가)
### 파일 쓰기 모드는 파일이 없으면 파일을 만든 후 저장하고, 파일이 있으면 파일에 저장된 내용을 지우고 다시 저장한다. (덮어쓰기)
### 디스크에 저장된 파일을 열어서 작업을 한 후 반드시 파일을 닫아야 한다.

file = open('testData.txt', 'w') # 파일 열기
for i in range(1, 11):
    # 파일 변수에 write() 함수를 이용해서 출력한다.
    # \n : new line, 줄을 바꾼다.
    # \r : carriage return, 커서를 줄의 맨 처음으로 옮긴다.
    # file.write(str(i) + '\r\n')
    file.write('{0:02d}번째 줄 입니다.\r\n'.format(i))
file.close() # 파일 닫기
print('파일로 쓰기 완료')
#=============== RESTART: D:\osc\workspace\16_fileReadWrite.py ===============
#파일로 쓰기 완료

# 파일의 위치를 지정하는 방법은 절대 경로 지정 방식과 상대 경로 지정 방식이 있다.
# 절대 경로 : 파일이 저장된 디스크 드라이브의 최상위(root) 디렉토리(폴더)부터 텍스트 파일이 저장된 디렉토리 까지의 경로를 의미한다.
# 상대 경로 : 실행되는 파이썬 프로그램 파일이 위치한 디렉토리 부터 텍스트 파일이 저장된 디렉토리 까지의 경로를 의미한다.
#             .은 실행되는 파이썬 프로그램이 저장된 경로를 의미한다.
#             ..은 실행되는 파이썬 프로그램이 저장된 경로의 한단계 상위 경로를 의미한다.
# 파일의 위치를 지정할때 파일의 이름만 적으면 실행되는 파이썬 프로그램 파일이 위치한 디렉토리를 의미한다.
# 경로 지정시 디렉토리와 디렉토리, 디렉토리와 파일을 구분하기 위해 \\를 사용해야 한다.

# 키보드로 입력하는 문자열을 텍스트 파일로 저장하는 프로그램
# quit가 입력되면 저장을 종료한다. quit는 소대문자를 구분하지 않는다.
# filePath = 'D:\\osc\\workspace\\Data\\testData2.txt' # 절대경로
#filePath = '..\\workspace\\Data\\testData2.txt' # 상대경로 case1
filePath = '.\\Data\\testData2.txt' # 상대경로 case2
file = open(filePath, 'w')
while True:
    string = input('입력 >>> ')
    if string.upper() == 'QUIT': # string.lower() == 'quit'
        break    
    file.write(string + '\r\n')
file.close()
print('입력 데이터 파일로 쓰기 완료')
#=============== RESTART: D:\osc\workspace\16_fileReadWrite.py ===============
#입력 >>> 111
#입력 >>> 222
#입력 >>> 333
#입력 >>> 444
#입력 >>> 555
#입력 >>> quit
#입력 데이터 파일로 쓰기 완료
